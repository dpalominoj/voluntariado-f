# tests/test_prediction_service.py
import pytest
from flask import current_app
from model.models import Usuarios, Actividades, Inscripciones, Recomendaciones, TipoRecomendacion, EstadoActividad, Organizaciones, db as app_db
from services.prediction_service import generate_user_based_recommendations, get_top_recommended_activities
import pandas as pd
from decimal import Decimal

# Helper function to create users, activities, and inscriptions
def setup_test_data(db):
    # Create an organization
    org1 = Organizaciones(nombre_org="Test Org 1")
    db.session.add(org1)
    db.session.commit()


    # Create Users
    user1 = Usuarios(DNI="111", nombre="User One", perfil="voluntario")
    user1.set_password("pass1")
    user2 = Usuarios(DNI="222", nombre="User Two", perfil="voluntario")
    user2.set_password("pass2")
    user3 = Usuarios(DNI="333", nombre="User Three", perfil="voluntario")
    user3.set_password("pass3")
    db.session.add_all([user1, user2, user3])
    db.session.commit()

    # Create Activities
    act1 = Actividades(nombre="Activity A", id_organizacion=org1.id_organizacion, estado=EstadoActividad.ABIERTO)
    act2 = Actividades(nombre="Activity B", id_organizacion=org1.id_organizacion, estado=EstadoActividad.ABIERTO)
    act3 = Actividades(nombre="Activity C", id_organizacion=org1.id_organizacion, estado=EstadoActividad.ABIERTO)
    act4 = Actividades(nombre="Activity D", id_organizacion=org1.id_organizacion, estado=EstadoActividad.ABIERTO) # Not inscribed by anyone initially
    db.session.add_all([act1, act2, act3, act4])
    db.session.commit()

    # Create Inscriptions
    # User1: A, B
    # User2: B, C
    # User3: A, C
    ins1_1 = Inscripciones(id_usuario=user1.id_usuario, id_actividad=act1.id_actividad)
    ins1_2 = Inscripciones(id_usuario=user1.id_usuario, id_actividad=act2.id_actividad)
    ins2_1 = Inscripciones(id_usuario=user2.id_usuario, id_actividad=act2.id_actividad)
    ins2_2 = Inscripciones(id_usuario=user2.id_usuario, id_actividad=act3.id_actividad)
    ins3_1 = Inscripciones(id_usuario=user3.id_usuario, id_actividad=act1.id_actividad)
    ins3_2 = Inscripciones(id_usuario=user3.id_usuario, id_actividad=act3.id_actividad)
    db.session.add_all([ins1_1, ins1_2, ins2_1, ins2_2, ins3_1, ins3_2])
    db.session.commit()

    return user1, user2, user3, act1, act2, act3, act4

def test_generate_recommendations_for_user(database): # Use the database fixture
    user1, user2, user3, act1, act2, act3, act4 = setup_test_data(database)

    # User1 participated in A, B. User2 in B, C. User3 in A, C.
    # User1 is similar to User2 (common: B) and User3 (common: A).
    # Expected for User1: Recommendation for C (from User2 or User3)
    generate_user_based_recommendations(target_user_id=user1.id_usuario)

    recommendations_u1 = Recomendaciones.query.filter_by(id_usuario=user1.id_usuario).all()
    assert len(recommendations_u1) > 0
    recommended_act_ids_u1 = {rec.id_actividad for rec in recommendations_u1}
    assert act3.id_actividad in recommended_act_ids_u1 # Activity C
    assert act1.id_actividad not in recommended_act_ids_u1 # Already participated
    assert act2.id_actividad not in recommended_act_ids_u1 # Already participated

    # Expected for User2: Recommendation for A (from User1 or User3)
    # Need to clear recommendations for user2 if any were created by "all users" run or side effects
    database.session.query(Recomendaciones).filter_by(id_usuario=user2.id_usuario).delete()
    database.session.commit()
    generate_user_based_recommendations(target_user_id=user2.id_usuario)
    recommendations_u2 = Recomendaciones.query.filter_by(id_usuario=user2.id_usuario).all()
    assert len(recommendations_u2) > 0
    recommended_act_ids_u2 = {rec.id_actividad for rec in recommendations_u2}
    assert act1.id_actividad in recommended_act_ids_u2 # Activity A

def test_generate_recommendations_all_users(database):
    user1, user2, user3, act1, act2, act3, act4 = setup_test_data(database)
    generate_user_based_recommendations() # For all users

    recommendations_all = Recomendaciones.query.all()
    # User1 gets C. User2 gets A. User3 gets B. Total 3 recommendations.
    # Check if each user received at least one recommendation.
    # User1 should get C
    # User2 should get A
    # User3 should get B
    # So, there should be at least 3 recommendations in total.
    # If a user has no one similar or no new activities from similar users, they might not get recs.

    # Let's verify specific expected recommendations
    expected_description = "Generated by user-based collaborative filtering"

    rec_u1_for_c = Recomendaciones.query.filter_by(id_usuario=user1.id_usuario, id_actividad=act3.id_actividad).first()
    assert rec_u1_for_c is not None
    assert rec_u1_for_c.descripcion == expected_description
    assert rec_u1_for_c.score is not None
    assert isinstance(rec_u1_for_c.score, Decimal)
    assert rec_u1_for_c.score > Decimal('0.0') # Scores should be positive if users are similar

    rec_u2_for_a = Recomendaciones.query.filter_by(id_usuario=user2.id_usuario, id_actividad=act1.id_actividad).first()
    assert rec_u2_for_a is not None
    assert rec_u2_for_a.descripcion == expected_description
    assert rec_u2_for_a.score is not None
    assert isinstance(rec_u2_for_a.score, Decimal)
    assert rec_u2_for_a.score > Decimal('0.0')

    rec_u3_for_b = Recomendaciones.query.filter_by(id_usuario=user3.id_usuario, id_actividad=act2.id_actividad).first()
    assert rec_u3_for_b is not None
    assert rec_u3_for_b.descripcion == expected_description
    assert rec_u3_for_b.score is not None
    assert isinstance(rec_u3_for_b.score, Decimal)
    assert rec_u3_for_b.score > Decimal('0.0')

    # Total recommendations should be 3 based on this specific dataset and logic
    assert len(recommendations_all) == 3


def test_get_top_recommended_activities(database):
    user1, user2, user3, act1, act2, act3, act4 = setup_test_data(database)

    # Manually create some recommendations to test aggregation
    # Act4 recommended 3 times, Act1 recommended 2 times
    desc_manual = "Manual test recommendation"
    rec1 = Recomendaciones(id_usuario=user1.id_usuario, id_actividad=act4.id_actividad, tipo_recomendacion=TipoRecomendacion.PERSONALIZADA, score=Decimal('0.8'), descripcion=desc_manual)
    rec2 = Recomendaciones(id_usuario=user2.id_usuario, id_actividad=act4.id_actividad, tipo_recomendacion=TipoRecomendacion.PERSONALIZADA, score=Decimal('0.7'), descripcion=desc_manual)
    rec3 = Recomendaciones(id_usuario=user3.id_usuario, id_actividad=act4.id_actividad, tipo_recomendacion=TipoRecomendacion.PERSONALIZADA, score=Decimal('0.9'), descripcion=desc_manual)
    rec4 = Recomendaciones(id_usuario=user1.id_usuario, id_actividad=act1.id_actividad, tipo_recomendacion=TipoRecomendacion.PERSONALIZADA, score=Decimal('0.6'), descripcion=desc_manual)
    rec5 = Recomendaciones(id_usuario=user2.id_usuario, id_actividad=act1.id_actividad, tipo_recomendacion=TipoRecomendacion.PERSONALIZADA, score=Decimal('0.5'), descripcion=desc_manual)
    database.session.add_all([rec1, rec2, rec3, rec4, rec5])
    database.session.commit()

    top_activities = get_top_recommended_activities(limit=5)
    assert len(top_activities) == 2
    assert top_activities[0].id_actividad == act4.id_actividad # Act4 should be first (3 recommendations)
    assert top_activities[1].id_actividad == act1.id_actividad # Act1 second (2 recommendations)

def test_get_top_recommended_activities_empty(database):
    top_activities = get_top_recommended_activities(limit=5)
    assert len(top_activities) == 0

def test_recommendations_no_new_activities_for_target_user(database):
    user1, user2, user3, act1, act2, act3, act4 = setup_test_data(database)
    # Scenario: User1 has participated in Act1, Act2.
    # User2 (similar to User1) has participated in Act1, Act2.
    # No new activities for User1 from User2.
    # User3 participated in Act3, Act4 (not similar to User1 based on common activities with User1)

    # Clear existing inscriptions and set new ones for this specific test
    database.session.query(Inscripciones).delete()
    database.session.commit() # Commit the deletion

    # User1: Act1, Act2
    ins_u1_a1 = Inscripciones(id_usuario=user1.id_usuario, id_actividad=act1.id_actividad)
    ins_u1_a2 = Inscripciones(id_usuario=user1.id_usuario, id_actividad=act2.id_actividad)
    # User2: Act1, Act2
    ins_u2_a1 = Inscripciones(id_usuario=user2.id_usuario, id_actividad=act1.id_actividad)
    ins_u2_a2 = Inscripciones(id_usuario=user2.id_usuario, id_actividad=act2.id_actividad)
    # User3: Act3, Act4 (different activities)
    ins_u3_a3 = Inscripciones(id_usuario=user3.id_usuario, id_actividad=act3.id_actividad)
    ins_u3_a4 = Inscripciones(id_usuario=user3.id_usuario, id_actividad=act4.id_actividad)

    database.session.add_all([ins_u1_a1, ins_u1_a2, ins_u2_a1, ins_u2_a2, ins_u3_a3, ins_u3_a4])
    database.session.commit()

    generate_user_based_recommendations(target_user_id=user1.id_usuario)
    recommendations_u1 = Recomendaciones.query.filter_by(id_usuario=user1.id_usuario).all()

    # User1 should not get any recommendations from User2 because they share all activities.
    # User1 is not similar to User3 (no common activities in this setup).
    # So, User1 should receive no recommendations.
    assert len(recommendations_u1) == 0


def test_no_inscriptions(database):
    # Clear all inscriptions
    database.session.query(Inscripciones).delete()
    database.session.commit()

    # Create a user so the code doesn't fail on no users
    # (though generate_user_based_recommendations should handle no users in matrix)
    user_test = Usuarios(DNI="999", nombre="Test User No Ins", perfil="voluntario")
    user_test.set_password("test")
    org_test = Organizaciones(nombre_org="Org for NoIns Test")
    database.session.add_all([user_test, org_test]) # Add org if activities need it
    database.session.commit()

    # Add some activities, otherwise user_item_matrix might be empty in a way that bypasses some logic
    act_test1 = Actividades(nombre="Test Act X", id_organizacion=org_test.id_organizacion, estado=EstadoActividad.ABIERTO)
    database.session.add(act_test1)
    database.session.commit()


    # Test generate_user_based_recommendations with a specific user who has no inscriptions
    generate_user_based_recommendations(target_user_id=user_test.id_usuario)
    recommendations = Recomendaciones.query.filter_by(id_usuario=user_test.id_usuario).all()
    assert len(recommendations) == 0 # User has no interaction history, so no basis for CBF

    # Test generate_user_based_recommendations for all users when no inscriptions exist at all
    # This case is already implicitly handled by the function returning early if all_inscriptions_tuples is empty.
    # If we call it, it should print "No inscriptions data found." and not create any recommendations.
    # To be sure, let's check the recommendations table is still empty.
    Recomendaciones.query.delete() # Clear any potential previous recommendations
    database.session.commit()
    generate_user_based_recommendations()
    all_recs = Recomendaciones.query.all()
    assert len(all_recs) == 0


    # Test get_top_recommended_activities when no recommendations exist
    top_activities = get_top_recommended_activities()
    assert len(top_activities) == 0

def test_user_not_in_matrix(database):
    user1, user2, user3, act1, act2, act3, act4 = setup_test_data(database)

    # Create a new user who has no inscriptions and thus won't be in the user-item matrix
    org_new = Organizaciones.query.first() # Get existing org
    user_new = Usuarios(DNI="444", nombre="New User Not In Matrix", perfil="voluntario")
    user_new.set_password("newpass")
    database.session.add(user_new)
    database.session.commit()

    generate_user_based_recommendations(target_user_id=user_new.id_usuario)

    recommendations_new_user = Recomendaciones.query.filter_by(id_usuario=user_new.id_usuario).all()
    # The function should print a message and return, not generate recommendations
    assert len(recommendations_new_user) == 0

def test_no_similar_users(database):
    # User1 participates in Act1. User2 participates in Act2. No common activities.
    database.session.query(Inscripciones).delete()
    database.session.query(Actividades).delete()
    database.session.query(Usuarios).delete()
    database.session.query(Organizaciones).delete()
    database.session.commit()

    org = Organizaciones(nombre_org="Org Similar")
    database.session.add(org)
    database.session.commit()

    u1 = Usuarios(DNI="555", nombre="User Alpha", perfil="voluntario"); u1.set_password("p")
    u2 = Usuarios(DNI="666", nombre="User Beta", perfil="voluntario"); u2.set_password("p")
    database.session.add_all([u1, u2])
    database.session.commit()

    a1 = Actividades(nombre="Act Alpha", id_organizacion=org.id_organizacion, estado=EstadoActividad.ABIERTO)
    a2 = Actividades(nombre="Act Beta", id_organizacion=org.id_organizacion, estado=EstadoActividad.ABIERTO)
    database.session.add_all([a1, a2])
    database.session.commit()

    ins1 = Inscripciones(id_usuario=u1.id_usuario, id_actividad=a1.id_actividad)
    ins2 = Inscripciones(id_usuario=u2.id_usuario, id_actividad=a2.id_actividad)
    database.session.add_all([ins1, ins2])
    database.session.commit()

    generate_user_based_recommendations(target_user_id=u1.id_usuario)
    recs_u1 = Recomendaciones.query.filter_by(id_usuario=u1.id_usuario).all()
    # u1 and u2 have 0 similarity. So u1 should not get any recommendations from u2.
    assert len(recs_u1) == 0

    generate_user_based_recommendations(target_user_id=u2.id_usuario)
    recs_u2 = Recomendaciones.query.filter_by(id_usuario=u2.id_usuario).all()
    assert len(recs_u2) == 0
